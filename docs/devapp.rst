Developing an OP2 Application
=============================

This page provides a tutorial in the basics of using OP2 for unstructured-mesh application development.

Example Application
-------------------

The tutorial will use the Airfoil application, a simple non-linear  2D  inviscid  airfoil code that uses an unstructured mesh. It is a finite volume application that solves the 2D Euler equations using a scalar numerical dissipation. The algorithm iterates towards the steady state solution, in each iteration using a control volume approach - for example the rate at which the mass changes within a control volume is equal to the net flux of mass into the control volume across the four faces around the cell.

Airfoil consists of five loops, ``save_soln`` , ``adt_calc`` , ``res_calc`` , ``bres_calc`` and ``update``, within a time-marching iterative loop. Out of these, ``save_soln`` and ``update`` are what we classify as direct loops where all the data accessed in the loop is defined on the mesh element over which the loop iterates over. Thus for example in a direct loop a loop over edges will only access data defined on edges. The other three loops are indirect loops. In this case when looping over a given type of elements, data on other types of elements will be accessed indirectly, using mapping tables. Thus for example ``res_calc`` iterates over edges and increments data on cells, accessing them indirectly via a mapping table that gives the explicit connectivity information between edges and cells.

The standard mesh size solved with Airfoil consists of 1.5M edges.  Here the most compute intensive loop is ``res_calc``, which is called 2000 times during the total execution of the application and performs about 100 floating-point operations per mesh edge.

* Go to the ``OP2/apps/c/airfoil/airfoil/airfoil_tutorial/original`` directory and open the ``airfoil_orig.cpp`` file to view the original application.
* Use the Makefile in the same directory to compile and then run the application. The ``new_grid.dat`` (downloadable from `here <https://op-dsl.github.io/docs/OP2/new_grid.dat>`__) needs to be present in the same directory as the executable.
* The program executes by reporting the rms value of the pressure held on the cells for every 100 iterations and ends by comparing this value to the reference value of the computation at 1000 iterations. If the solution is within machine precision of the reference value, the execution is considered to be validated (PASS). This is the same criteria required to validate any parallel versions of the application, including the paralleizations generated by OP2 as detailed below.


Original - Load mesh and initialization
---------------------------------------
The original code begins with allocating memory to hold the mesh data and then initializing them by reading in the mesh data, form the ``new_grid.dat`` text file:


.. code-block:: C

  FILE *fp;
  if ((fp = fopen(FILE_NAME_PATH, "r")) == NULL) {
    printf("can't open file FILE_NAME_PATH\n");
    exit(-1);
  }
  if (fscanf(fp, "%d %d %d %d \n", &nnode, &ncell, &nedge, &nbedge) != 4) {
	printf("error reading from FILE_NAME_PATH\n");
	exit(-1);
  }

  cell   = (int *)malloc(4 * ncell  * sizeof(int));
  edge   = (int *)malloc(2 * nedge  * sizeof(int));
  ecell  = (int *)malloc(2 * nedge  * sizeof(int));
  bedge  = (int *)malloc(2 * nbedge * sizeof(int));
  becell = (int *)malloc(1 * nbedge * sizeof(int));
  bound  = (int *)malloc(1 * nbedge * sizeof(int));
  x      = (double *)malloc(2 * nnode * sizeof(double));
  q      = (double *)malloc(4 * ncell * sizeof(double));
  qold   = (double *)malloc(4 * ncell * sizeof(double));
  res    = (double *)malloc(4 * ncell * sizeof(double));
  adt    = (double *)malloc(1 * ncell * sizeof(double));

  for (int n = 0; n < nnode; n++) {
	if (fscanf(fp, "%lf %lf \n", &x[2 * n], &x[2 * n + 1]) != 2) {
  	  printf("error reading from FILE_NAME_PATH\n");
  	  exit(-1);
	}
  }

  for (int n = 0; n < ncell; n++) {
    if (fscanf(fp, "%d %d %d %d \n", &cell[4 * n], &cell[4 * n + 1],
        &cell[4 * n + 2], &cell[4 * n + 3]) != 4) {
      printf("error reading from FILE_NAME_PATH\n");
      exit(-1);
    }
  }
  for (int n = 0; n < nedge; n++) {
	if (fscanf(fp, "%d %d %d %d \n", &edge[2 * n], &edge[2 * n + 1],
        &ecell[2 * n], &ecell[2 * n + 1]) != 4) {
      printf("error reading from FILE_NAME_PATH\n");
  	  exit(-1);
    }
  }
  for (int n = 0; n < nbedge; n++) {
    if (fscanf(fp, "%d %d %d %d \n", &bedge[2 * n], &bedge[2 * n + 1],
        &becell[n], &bound[n]) != 4) {
    printf("error reading from FILE_NAME_PATH\n");
    exit(-1);
    }
  }
  fclose(fp);


The code then initialize ``q`` and ``res`` data arrays to 0.

Original - Main iteration and loops over mesh
---------------------------------------------

The main iterative loop is a for loop that iterates for some ``NUM_ITERATIONS`` which in this case is set to 1000 iterations.  Within this main iterative loops there are 5 loops over various mesh elements (as noted above) including direct and indirect loops.


Build OP2
---------
Build OP2 using instructions in the `Getting Started <fhttps://op2-dsl.readthedocs.io/en/latest/getting_started.html>`__. page.

Step 1 - Preparing to use OP2
-----------------------------

First, include the following header files, then initialize OP2 and finalize it as follows:

.. code-block:: C

  #include "op_seq.h"
  ...
  ...
  int main(int argc, char **argv) {
    //Initialise the OP2 library, passing runtime args, and setting diagnostics level to low (1)
    op_init(argc, argv, 1);
    ...
    ...
    ...
    free(adt);
    free(res);

    //Finalising the OP2 library
    op_exit();
  }

By this point you need OP2 set up - take a look at the Makefile in step1, and observe that the include and library paths are added, and we link against ``op2_seq`` back-end library.


Step 2 - OP2 Declaration
------------------------

* Declare sets - The Airfoil application consists of four mesh element types (which we call sets): nodes, edges, cells and boundary edges. These needs to be declared using the ``op_set`` API call together with the number of elements for each of these sets:

.. code-block:: C

  // declare sets
  op_set nodes  = op_decl_set(nnode,  "nodes" );
  op_set edges  = op_decl_set(nedge,  "edges" );
  op_set bedges = op_decl_set(nbedge, "bedges");
  op_set cells  = op_decl_set(ncell,  "cells" );

Later, we will see how the number of mesh elements can be read in directly from an hdf5 file using the ``op_set_hdf5`` call.

When developing your own application with OP2, or indeed converting an application to use OP2, you will need to decide on what mesh element types, i.e. sets will need to be declared to define the full mesh. A good starting point for this design is to see what mesh elements are used the loops over the mesh.

* Declare maps
* Declare dats
* Declare constants

Finally compile the step2 application and execute. You will note that the full application still runs and validates as OP2, with the sequential back-end simply uses the allocated memory for sets, maps and data in the declaration, without internally de-allocating them. This helps the developer to gradually build up the application with the conversion to OP2 API (as we are do here), checking for validation on each step. However, this will only work for this developer sequential version, where none of the parallel versions generated via the code generator nor the code generated sequential version ``gen_seq`` will work as they de-allocate the initial memory and move the mesh to obtain best parallel performance.

Step 3 - First parallel loop : direct loop
------------------------------------------
* Outline kernel
* Declare parallel loop with ``op_par_loop``

Step 4 - Indirect loops
-----------------------
* Details of ``op_par_loop`` for indirect loops

Step 5 - Global reductions
--------------------------
* Details of ``op_par_loop`` for specifying global reductions


Step 6 - Handing it all to OP2
------------------------------
* Now can run a sequential version and validate results
* Partitioning call for MPI
* Parallel file I/O
* details on ``op_fetch_data`` call

Step 7 - Code generation
------------------------
* Code-gen command
* Link and execute parallel versions with Makefiles
* Use OP2's c_app Makefiles

Code generated versions
-----------------------

Optimizations
-------------
* Brief notes on runtime and optimization flags
* Provide link to Performance tuning page in the docs
